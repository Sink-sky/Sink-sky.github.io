{"pages":[{"title":"关于","text":"很显然,这是一个菜鸡程序员的博客😃 🙂关于我想要成为一名C++程序员 宅属性爆棚,社恐患者,喜欢安静,对一切事物运行的机制感到好奇. 兴趣动漫,游戏,折腾小工具,看书. 写博客的初衷是为了表达自己的想法.也仅仅只是个人的看法而已.","link":"/about/index.html"}],"posts":[{"title":"Async","text":"怎样好的异步编程？ 同步异步首先，我们需要了解什么是异步。 从编程的角度来看，程序是一串执行流，从大的尺度来说，是一个个逻辑流（也可以说是函数），从小的尺度来说，是一条条的指令。对于函数，如果不能在某串逻辑流中固定时机得到调用，那么相对于该逻辑流而言，该函数是异步的。反之，则是同步的。 之所以要强调对逻辑流而言，是想说明同步异步的概念显然是和语境相关的，描述的是多个逻辑流之间的关系。程序是死的，程序员总得告诉计算机下一步该做什么，从全局的角度来看，程序员的程序让计算机干什么计算机就得干什么，因此所有调用都能在这全局语境上找到确定时机，计算机只做确定的事情。 因此，进程间通信中，信号相对于进程是异步的，多线程编程中，线程之间是相互异步的。这些异步逻辑流的交叉细粒度是指令级别的，即逻辑流可能在执行任何一条指令的时候，被打断执行，被插入一段原逻辑流意料之外的异步逻辑流。对于原逻辑流来说，一段异步逻辑流会导致语境变化，原来做的判断可能不再成立；对于异步逻辑流来说，其执行的上下文是不确定的。这些区别都会使我们需要注意或者花费额外的代码，以保证在这样的环境下异步逻辑流能够正确的执行。对于进程信号处理来说，我们需要关心函数的可重入，对于多线程编程来说，我们需要关心函数是否线程安全。资源共享以及潜在的编译重排（甚至是 CPU 级别乱序执行及缓存一致性）都将影响程序的正确性。 对于多进程多线程这种天然多执行流并行的结构来说，它们都强制要求逻辑流必须满足指令级任意交叉的正确性，因为逻辑流的调度是抢占式的，逻辑流没办法得到不被打断的保证。在没有同步机制的情况下，逻辑流之间的执行次序也是完全无法确定的。 怎样并行在函数式编程中，一个函数的输入是确定的，那么该函数的输出也是确定的。由此，一个函数唯一的作用在于对输入输出做变换，而不会产生任何的副作用。我们可以像数学代数运算一样对函数调用进行处理，将一个元素与其逆元相消。函数式编程天然是对并行友好的，函数之间是相互独立的，程序中函数之间的依赖只体现在输入输出之间的依赖。如果计算过程中，A 和 B 之间没有输入输出之间的依赖，显然任意安排 A、B 之间的计算顺序，都不会对最终结果产生任何影响，它们是次序无关的。 按函数式编程的想法来理解，多执行流之间的依赖越少越好。如果执行流之间完全没有状态依赖，我们需要的只是输入输出，那么无论执行流之间以任何细粒度交叉执行，都不会影响到程序的正确性。当然，这只是一种理想情况，程序不是孤岛，绝对形式化的要求会严重影响效率以及可读性。将一个程序并行化，需要设计一系列的方案来减少执行流之间的时域耦合，比如采取 Golang 中 “不要通过共享内存来通信，而应该通过通信来共享内存” 的哲学来显式最小化耦合。其中有的耦合是不可避免的，多且繁琐的同步意味着执行流可能并不适合并行化。 怎样并发指令级交叉下的正确性是抢占式调度的原罪，如果像协作式调度一样，程序可以自己决定交叉时机。虽然丧失了天然多处理器执行的能力，但程序变得更加灵活，上层程序知道如何选择恰当的时机让其他逻辑流交叉。在这种恰当的时机下，上层程序对共享状态的处理对其他逻辑流来说可以是原子性的，由此避免了加锁带来的性能下降；上层程序能够有一个上层调度中心，当继续执行下去的条件不满足时，可以向调度中心注册条件监听。调度中心能够掌握逻辑流的执行条件，避免唤醒逻辑流尝试判断执行条件，导致时间浪费。 怎样异步无论是多线程还是协程，都是一种异步编程。在可能交叉逻辑流的地方，当前逻辑流的语境可能会随着逻辑流的交叉而产生改变，原来所做隐形的约束都可能被打破。为保证逻辑流的正确性，需要尽可能地保证约束不被打破，可能是加锁保证独占，可能是冗余提升隔离性，还可能是反过来检查约束是否满足做出对应的处理。 想要尽可能使用异步提升效率，对于时域耦合严重的逻辑流，使用协作式的并发较好，而对于独立性相对较高的逻辑流，可以将其放到不同线程上并行，最大利用多核优势。当然这一切只是纸上谈兵而已，具体做法还是得根据开销及场景来权衡。","link":"/2022/05/04/Async/"},{"title":"Coding","text":"编程,将逻辑编码成机器的’灵魂’ 魔法 相信的心,就是你的魔法! 编程很像是一种现代魔法.即使它并没有像人们想象的一样违反科学常识,其带来的吸引力却毫不亚于魔法.在键盘上敲下某一个字母,屏幕上就会显示对应字母;打开某个视频文件,电脑就会将其播放;乃至于在打印店中点击打印按钮,打印机就会将文档分毫不差的打印出来. 这些看似神奇的操作,实际上与计算机的层层抽象,密不可分.或许你会觉得其中的原理深不可测,但那实际上只是未知带来的恐惧.科学是属于大众的,任何知识最初都是由那一小撮想法发展而来的,经过思考分析论证而发扬光大.实际一点也不玄乎. 当你在算盘下打下一算珠,又打下一算珠时,实际上这已经完成了一次计算.可以从算盘上读出计算结果是二.这个想法的关键在于,给定一系列的规则(珠算口诀),将要计算的数按照规则输入,你得到了答案的算珠表示.而电子计算机只是将这一过程电子化,依赖快速的电压变化来进行高速计算.两者本质并无区别,而这恰是’魔法’的重要基础. 编码 形式不是关键,关键是语义. 自人类文明诞生之初,就在和编码打交道,计数法的发展就是一个例子.古代对象比较少,可以用绳结计数,一个绳结代表一个对象.后来对象比较多,就有了位的概念,不同位置的数依次代表着不同的权重.现在有科学计数法,能够简洁的表达不同量级的对象. 上述的例子都是在描述数目的多少,改变的只是表示的形式.编码就是一种映射,建立了形式与语义的联系.同样的表示形式,按编码的不同,可能会产生不一样的语义. 01000001是什么?显然,它可以表示字符01000001,也可以表示二进制1000001即十进制65的数字,同样在ASCLL码中,可以表示成字母A.甚至我们可以通过某一种编码,让它成为某个代数系统中的加号.它是什么,取决于用什么样的编码去解释它.不止数据可以被编码,操作同样也是可以编码的,就像在纸上写下运算符一般自然. 抽象 数学威力为何如此巨大,乃至于即使只是一行的式子,其寓意也胜过千言万语. 科学计数法的强大之处在于,用简短的信息描述了量级信息,不必将其一一用零表示.这个符号(概念)的强大之处在于我们关注的是量级的大小本身,而不是一定位数之后那些位的数字究竟是什么.它让我们明晰重点,突出概念,从一个更高级的概念入手,归纳出更高级的性质.如同牛顿时代之前的数学家对很多关于微积分的问题束手无策,而现在基本一个大学生经过较短的训练掌握微积分就能程序化的解决这些问题一样,我们得到了概念上的升华,从而更加得心顺手,并非现代人就比前辈要更加聪明. 无法忍受计算机电路01的低效理解,那我们就用一种叫做汇编语言的东西,去描述电路01的操作意义.无法忍受汇编语言对某一个电路操作描述,那我们就用一种叫做高级语言的东西,去包装汇编语言.将人类的逻辑翻译成计算机的逻辑,一层层抽象出来的概念,用它去成就更加伟大的概念. 模型 专业的事情就应该让专家来干 C语言成功的主要原因之一在于它很好的平衡了语言中与机器相关的部分.而许多现代编程语言更是很好的屏蔽了计算机底层信息,让使用者将更多的精力放在应对工作需求上. 汇编语言提供了一个处理器编程模型供人们使用.高级语言提供了一种与平台无关的编程模型供人们使用.实际上,高级语言的编程模型正是汇编语言的处理器编程模型抽象而来.抽象高层模型使我们’魔法’的威力更加强大(具有某种更高级的特性),缺点是细粒度变大了,无法关注过多细节.但人们可以从各个模型层次切入,在某个层次相对独立的工作,并在各个层次做出优化. 将一个问题抽象成不同层次的模型及模型内相对独立的模块成了我们面对大型工程的重要工具. 编译 模型之间的桥 编程就像是写文章.一篇描述数据流动的文章. 计算机只接受它的01语言,写出来的文章与之不在同一个世界.之所以我们的文章能够畅通无阻的被计算机所理解,是因为中间存在着编译器这座桥.它忠实的将语义传达给计算机,拉近我们与计算机的距离,以至于我们有时候都会忽略它.然而缺它不可,它是一种模型到另一种模型的桥梁,将模型中的行为与另一模型中的行为建立对应. 想要和外语人有心灵上的交通,最好懂一点外语. 总结写得很乱,其实想表达的主要想法有 编程并不难,就是根据模型写文章. 重要的是逻辑,模型可能变化大,但处理问题的逻辑是基本不变/缓慢变化的. 抽象模型和模块化是编程的重要思想. 数据和逻辑都能被编码,对此来说,重要的是如何解读它. 不同编程语言,面对不同问题,模型不同语义细粒度不同.学习编程语言,应该主要学习其抽象出来语言特性. 懂编译器解释器如何翻译你的代码语义还是很有必要的.","link":"/2019/06/02/Coding/"},{"title":"Python 简要指南","text":"前言Python 是一门易学难精通的语言。原因一方面是，掌握常用部分就能满足大部分工作场景，虽然写起来会稍显啰嗦；另一方面是，语言花样繁多，各种偏好语法糖看的人眼花缭乱。恰逢有新同学进组，自己又感觉有些心得体会，故挑选一些风格经验作为例子，分享一下我眼中的 Python。 鸭子类型 Duck Typing说到 Python，就不可避免的讲到鸭子类型，关于鸭子类型的详细介绍可以参考维基百科。简单来说，Python 是一门面向对象语言，类由方法与属性所构成，其定义了类上各种合法操作，一个类是“鸭子”，意味着这个类可以做“鸭子”所有合法操作，即具有相同（名字）的方法与属性。 举个例子，这里有一道完形填空，”___ 在水中游泳“，提问：这里应该填上什么，才能使上下文成立呢？按面向对象的方式来思考，这里能满足上下文的对象，应该具有“游泳”这种方法。“鸭子”可以在水中游泳，而不可能是“汽车在水中游泳”。面向对象编程就像这里的完形填空一样，上下文隐式约束填入的对象，就像方法函数隐式约束调用的形参。这些所有能够在水中游泳的对象，可以看作是同一范畴，暂且将其称作“游泳类”，如果要用面向对象的方式给定一个名称，即为类型的类 typeclass。 实际编程中，有许多这样的上下文，大大小小的各种函数方法，每个上下文都隐性要求某种范畴意义上的 typeclass，或许是“游泳类”又或是其他更复杂的。假如是在静态语言中，则必须要在上下文中标注上具体的类型，例如需要在函数调用前手动标注形参类型，而想要达到 typeclass 的效果，还需要用上相应静态语言多态的功能，因为其不仅限定于某种具体的类型，如具体函数调用会依据实际类型而变化。在 Python 这种动态语言中，情况变得简单，一些尽在不言之中，约束是隐式的，实现无需额外声明，解释器只是根据名字查找调用，只要对象满足约束即可正常运行。Python 将其称为结构子类型，以区别于传统静态面向对象语言中的名义子类型。 动态类型加上结构子类型的直接结果是，Python 是一门重语义、协议的语言。要从程序意义上兼容原有对象，需要替换对象实现原有对象所有操作即可，实现属性访问结构子类型上的兼容。要从使用意义上兼容原有对象，需要有一致的使用模型，及对应模型操作兼容的语义。在 Python 中，类似“游泳类”这样的 typeclass 可以使用协议去描述，协议中声明了各种操作所需的基本语义。在单个对象上的使用上，隐式满足不同协议，就像光具有波粒二象性，能自由的用在需要波动与粒子的上下文中。在不同上下文环境的使用中，使用一致的协议，不同的实现，等价的结构，以满足对高层隔离具体细节的目的，就像帧同步框架中，需要先建立一套确定性、平台无关的操作原语，才能保证游戏状态一致性。 在 Python 标准库的 collections.abc 中定义了各种容器的抽象基类，在实际数据操作温和抽象数据结构使用方式的时候不妨多多使用，在简单定义几个基础的抽象方法后，即可获得像内置数据结构一样的支持体验，其他更多内建方法也会基于这些抽象方法语义能够使用，达到基于操作语义编程的目的。OrderedDict、defaultdict、CaseInsensitiveDict 等都是值得参考的例子。Python 魔术方法作为会被解释器隐式调用的特殊方法，也是基于操作语义编程的一种表现，其理念贯彻于 Python 数据模型之中，相应介绍可以参见《流畅的 Python》第一章：Python 数据模型。 继承与混入类 Super &amp; Mixin传统面向对象语言中，继承一般是实现动态子类型的一种手段。Python 由于鸭子类型的存在，并不需要继承这种名义上的强约束。在 Python 中引入继承，一个原因是确实要表达 is-a 关系，减少重复代码编写量（谁还不想偷点懒呢），另一方面是用来组合，作为同一对象不同性质的复合，常见相关的惯用法有 Mixin。 Python 支持多重继承，如果对 C++ 中的多重继承有所了解，可能会认为这是一项麻烦的特性，立体复杂的菱形继承结构走向未知的浑沌。虽然两者都叫多重继承，但是 Python 中的某些设定避免了成为 C++ 中那样怪物般的特性。首先，Python 中的菱形继承顶部基类只会有一份，不会有冗余、二义性的问题。其次，Python 使用 C3 线性化算法来解析 MRO，将多重继承中复杂结构拍扁成一个 list 的线性结构，同时保留继承链中所有父子类的偏序关系，皆由这种偏序关系与继承顺序推导出一个全序关系。 Super 则是与 MRO 相互搭配的设计，目的为沿着对象实例实际类型的 MRO 顺序依次调用，保证不遗漏调用 MRO 任何一个类的方法。Super 的语义是指向 MRO 链中当前方法调用类所在位置的下一个类，让我们据此仔细考察一下 Super 的使用情形。第一，我们不能对方法调用顺序作任何直接先后上的假定，举个例子，假如有继承链 A &lt;- B 表示 B 继承于 A，我们可以认为 B 实例 Super 方法调用会直接到 A 方法调用吗？答案是不行，考虑有继承链 A &lt;- C 与 (B, C) &lt;- D，其中后者表示 D 多继承于 C 跟 B，此时 D 的 MRO 会变成 [D, B, C, A]，B 使用 Super 调用将直接到 C，所以在 Super 调用链中我们只能得到父子类偏序关系调用顺序的保证，这种只有顺序依赖上的保证实际上比想象的要弱。第二，在单继承的情况下，其实没有必要使用 Super，调用是静态唯一确定的，直接用类方法调用替代即可，由此还可获得第一点讨论的直接调用顺序上的保证。 综上所述，Super 实际上是服务于利用多重继承进行组合的，为了不同行为组合成统一对象，或者是插件式单一对象行为功能的扩充。前者，结合鸭子类型的想法，我们可以想象用类去表示不同的能力，对象继承于这个类说明对象能够干这些事，组合不同的这样的能力类来表达对象的能力范畴，Super 在这样的情况下扮演的是个简单的调和者，对象的方法一旦在继承的多个能力中定义，组合的方式就要求解决如何统一同一操作不同能力定义冲突。后者，在 Python 中常惯用于 Mixin，详细的使用例子可以参照 StackOverflow 上的这个回答。 总之，Super 适用于插件式的加载调用，每个调用按照依赖顺序先后调用有且仅有一次。一旦涉及到复杂情况需要调和冲突，屏蔽其中某些调用，表现出不同的行为，甚至是父类内在语义的变更，那最好直接用类调用替代 Super 调用，本质上抽象类的分层已经被打破了，只能控制在我们能够掌控的规模，而不能通过这种简单的性质组合起来。关于 Super 详细的一些介绍使用，更多可以参考 Python’s super() considered super! 一文。 修改与混乱 Hack &amp; Chaos鸭子类型是一把双刃剑，一切尽在不言中，混乱也是。Python 中最常见的事情之一，就是伪装，property 可以伪装成属性，装饰器返回值可以伪装成被装饰的对象，unittest 里面有 mock 伪装做单元测试等。各种各样的伪装，魔术方法的隐式调用，语法糖的包装，真真假假真真，对象所处的世界就像是黑客帝国中设定那般虚幻。只要能凑齐必要的信息，Python 可以通过各种 hack 方式达到想要的目的，再经过语法糖的精心包装，看上去就像是 web 前端一样优雅。而后面不同的各种 hack 方式、状态存取、潜在的 hack 方式冲突、各种 hack 相互叠加导致的问题，都是一堆定时炸弹，不合预期的操作可能导致 C++ 未定义行为一样的惊喜。 代码总是在演进的，鸭子类型的一个核心问题是，很难定义一个良好的语义，也很难在一开始就设计一个良好的模型，与渐进式的代码开发实际上是有些冲突的。分模块不同人维护的情况下，很难达成共有的语义一致。一开始以为是一致的某些行为，最后发现在某些情况下还是有区别的，需要做某些 isinstance 的判别。连理解标准库及内置的一大堆协议来正确使用它们，大部分人都不怎么清楚，这种隐式规则的具象化体现，就是一篇篇的规范手册与缘由简介。 在一门灵活动态的语言中，有无数条路通往终点，又该怎么找到简洁有效那一条呢？There should be one– and preferably only one –obvious way to do it.显式优于隐式，可以用语法元素显式的将语义标记出来，再用hack的手段包装下方便使用。一般 hack 的方式有元类、魔术方法、装饰器、属性描述符，详细的使用可以参照《流畅的 Python》中相关章节。 OtherstypehintPython 是一门动态语言，不代表它没有类型或是类型不重要。提供类型标识重要的一点在于，可以把 Python 中可以静态确定的那部分信息，显式表达出来。目的是可以提供更好的可读性，指导类型检查器及时发现很多问题，配合IDE、文档生成工具提高开发效率。不得不吐槽的是，这方面还很不完善，typing 中标准集合的注释，到了 Python 3.9 因为 class_getitem 加入就被标记废除掉了，参见 PEP 585 与 StackOverflow 上的讨论。关于这些静态类型提示信息，一些库(pydantic)用来做数据的约束检查，而类型标注实际上是有成本的，相关的解决前向引用的字符串标注也带来了很多问题，相关讨论可以在《流程的Python》15 章：类型提示进阶中找到。个人认为，将不完善的类型标注引入实际上有点不负责，虽然在实践中可以更好的改进，但是不断引入类型信息黑魔法及破坏性更改，无疑是对社区信任的伤害。Typehint 的使用，可以参照这篇文章。 pattern match新引入的 match case 语法以及 args 与 kwargs 正确使用感觉很有必要，详细可以找找网上的资料。 tool chainPython 是一门动态语言，很多时候由于静态类型信息的缺失，可读性及代码健壮性都会受到影响。工具是一个很好的手段帮助提升整体代码质量，很多时候我们需要自己去做工具，以帮助我们去发现自己模型语义上的错误。对于大型工程开发来说，Python 实际上是把一部分开发质量交给了需要自己去做工具约束。胶水语言的特性，也使得做工具变得比较简单，相关的开发工具有 black, mypy, pre-commit，掌握 poetry 以方便将你的代码写成库，便于发布包管理依赖也很重要。","link":"/2023/07/11/Python%20%E7%AE%80%E8%A6%81%E6%8C%87%E5%8D%97/"},{"title":"const语义","text":"执行一段非法C++代码时出现了问题 1234567891011121314#include&lt;iostream&gt;using namespace std;int main(void){ const int a = 1; int *p = (int *) &amp;a;// cout &lt;&lt; &quot;Before:\\n&quot;;// cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;a &lt;&lt; endl;// cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl; *p = 100;// cout &lt;&lt; &quot;After:\\n&quot;;// cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; &amp;a &lt;&lt; endl;// cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl; return 0;} 输出为： 123456Before:0x6ffe44 0x6ffe441 1After:0x6ffe44 0x6ffe44100 1 地址&amp;a和p是相等的，然而a和*p的值却不相同。原因在于C++编译器在编译时会采用一种叫做变量折叠的技术。 变量折叠：在编译器里进行语法分析的时候，将常量表达式计算求值，并用求得的值来替换表达式，放入常量表。 将上述代码转换为C语言之后,地址相同值不同的问题没有发生. 查询到这是种编译器优化之后,开启-O0依旧无法避免. 最后发现是因为C和C++的const实际执行的语义不同而引起的. C语言中,const修饰变量将被放在.rodata段中,不代表是个常量,单纯意味着只读,是一种运行时const. C++语言中,const修饰变量将在编译时直接将变量引用位置替换成对应常量,相当于具有类型保护的define,是一种编译期const. 在C和C++中,const变量确实会被上述代码所改变,但是C++在运行时改变const,再次读取的还是编译器符号表中的常量数据. 解决方法是在变量前加上volatile,volatile告诉编译器每次调用变量都需要从内存重新取值,从而解决问题. 参考C++ 常量折叠问题的理解 Variably modified array at file scope","link":"/2019/06/04/const%E8%AF%AD%E4%B9%89/"},{"title":"Whycpp","text":"安利C++ Why C++?这是一篇说服你来学C++的文章.(🤔劝你向善? 对于软件开发甚至是计算机科学学习来说,C++是一门很好的语言.当然如果本身抱有的目的就不是学习本身为目的的话,那么针对你所要学习的领域进行特性化的学习即可,但我仍然建议你有时间来看看C++这门语言. Words can kill 语言可以杀戮 《虐杀器官》中的语言学武器令人影响深刻.C++不像科幻电影中那样”神通广大”,它只是一门编程语言.核心在于,语言虽说只是一种工具,但确实无时无刻的在潜移默化的影响着其使用者,某种意义上来说,数学也是一样. C++语言的设计哲学是接近零开销的抽象.语法层面上基本兼容C,使其具有接近底层的编程模型.同时给与程序员几乎以最大程度的自由.而面向对象编程与泛型编程则是C++最重要的编程范式,有点冰与火的感觉,却又相辅相成,你中有我,我中有你.这种不同范式之间的有机结合使得C++具有无比强大的威力,接近底层使得其可以极好的利用编译器的优化来尽可能优化你的代码,如果你想,甚至可以将一些运行期的工作放到编译期来做. 学习C++,你需要建立对整个程序的生命周期的良好理解.一个C++程序有编译,链接,执行等等过程. 编译过程涉及编译原理,其中词法分析,语法分析,语义分析,能够较好的让你理解高级程序语言的本质,以致于IDE中的静态代码分析工具是如何工作的.让写代码就像写文章一样,其中编译器的作用不言而喻;链接过程涉及程序逻辑的组织,库的设计与作用逻辑,一个个小代码文件是如何生成一个可供计算机运行的庞然大物,C++中各种各样的标识符是如何被解析引用的;执行过程让你有一个对进程执行的大致抽象,其中的堆和栈是什么,程序的运行建立在怎样的一个基础上,程序又如何与其他程序进行交互.进行系统调用,又或者是网络通信?其中的每一块细细长谈都可能耗尽你毕生时光. 如果说抽象与封装是程序组织的灵魂,模板与对象给你提供了良好的保障.对象给你一种运行时多态,而模板给你一种编译时多态.C++将类型系统的特征发挥的淋漓尽致,不但给你提供强大的类型保证,同时还给予你以破坏它们的工具.不但允许你进行隐式类型转化,让你方便写程序,同时允许你限制这种转换.从此意义看,C++是充满着矛盾的,然而其真的矛盾吗?没有,它只是给与设计者在设计中自由权衡的机会. 你可能会觉得C++是一门古老的语言从而缺乏活力.然而C++20已经蓄势待发.从C++98到C++11让C++焕然一新,编程效率得到极大提升.作为一门跨平台的语言,它的发展不仅仅建立在对新生编程模型应用的支持上,同时建立在语义细粒度和流行设计概念的支持上.如果说一门学科的发展依赖于概念的逐步澄清,那C++无疑是无比成功的.移动语义和final等关键字就是最好的佐证.学习C++不仅在于学习其语言特性,往往还需要学习一些最佳实践,从中你可以看到许多其它语言的影子,这也是学习C++给你带来的丰厚回报.良好的编程实践以及贯穿的知识体系,都让你的能力得到了实质性的提升. C++的缺点也是十分明显的.它太复杂了,想学好需要付出大量的时间,以致于没有人敢说自己真正”精通”C++.面对实际应用开发我只需要常常用到其中一部分就够了.如果我需要语言运行时的动态支持,何必拿C++设计半天,而不换一门动态语言来编写呢?面对工作需求已经够烦了,C++仍就要求你给它一份不小的精力关怀.如果你是直接面向工作学习编程语言的话,除非工作需要,否则按照工作需求优先学习吧. 如果你打算学习C++了,可以参考以下资料: 一个典型的 C++ 程序员成长经历 如何系统地学习 C++ 语言？ 如果你觉得上述理由仍就不够打动你,而你又看动漫的话,我这还有一个推荐的理由:因为,我们生来便是自由的! 参考如何评价《虐杀器官》这一部作品？ C++语言的设计与演化 Effective C++","link":"/2019/06/13/whycpp/"},{"title":"开发环境建设指南","text":"程序开发工具环境的一些理解 程序开发是一项工程，搭建开发环境则是工程的第一步。好的代码注重简洁性，一个好的开发环境与此类似。通过简要操作来方便的对程序进行修改验证及调试，避免繁琐操作打断思考的连续性。 开发环境的建设是一个权衡过程，我们需要在精力花费与效率提升中取得一个较好的平衡。颠倒工具与目的主次，将大量时间花费在工具上是不值得的，但从长期而言，开发人员有大量时间与工具打交道，因此也完全有充足的理由把工具打造得顺手。 开发环境的建设是一个迭代过程，我们需要不断修正它以适应新的开发需求。一般通用开发环境都会提供拓展的功能，将外部的操作抽象成内部的一个对象，使之纳入到通用开发环境的范畴中，从而提供一致性的操作方式，并与范畴中其他对象相互协作。 下面是个人配置环境的一些做法与想法，自己也算一个新手入门，寻找效率工具同时对美化也有一定追求，毕竟爱美之心人皆有之。以此作为分享供各位参考与讨论： 终端环境尽可能的使用键盘是提升效率的一种方法。图形界面往往需要在像素级的渲染上通过鼠标选择指定来进来操作，并且为了形象直观，通常会排列常用选项选择操作。而命令行程序对键盘操作更加友好，通过指定各种参数选项可以统一准确的对我们的目的进行描述，让程序严格去执行。命令行程序之间还可以通过 Shell 相互协作，图形程序则缺少这样的环境，也没有这样的传统。所以 Shell 是我们需要调教的第一步，通常来说，我们需要命令提示、命令补全、更方便的目录跳转来方便使用，实际上网上已经有很多成品方案，只需要安装然后个性化配置即可。 PowerShell 7Windows 自带的 cmd 太难用了，因此选择 PowerShell 作为主要的终端，默认自带的 PowerShell 是 v5.x 的，于是一步到位升级到了 v7。 PowerShell 中常使用 Cmdlet 命令，通常以动词-名词的组合命名名称，同时以.NET对象作为管道传输的信息载体。 PowerShell 需要先设置安全策略才能才能执行批处理脚本，这点相比 bat 即点即用对小白很不友好。 1Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine 然后安装一些模组： 123Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser -RequiredVersion 2.0.496Install-Module z -Scope CurrentUser 使用 VScode 编辑下 PowerShell 每次启动都会执行的脚本： 1code $profile 粘贴下面的配置到文件中： 123456789101112131415161718192021Import-Module posh-gitImport-Module oh-my-poshImport-Module zImport-Module PSReadLineSet-Theme ParadoxSet-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录 Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key UpArrow -ScriptBlock { [Microsoft.PowerShell.PSConsoleReadLine]::HistorySearchBackward() [Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()} # 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key DownArrow -ScriptBlock { [Microsoft.PowerShell.PSConsoleReadLine]::HistorySearchForward() [Microsoft.PowerShell.PSConsoleReadLine]::EndOfLine()} # 设置向下键为前向搜索历史纪录Clear-Host 重启 PowerShell 就配置完成了，z 命令可以用来快速跳转目录，也有命令提示和命令补全。 ZshLinux 下使用 Zsh 作为默认 Shell。使用 Zsh、Oh My Zsh、PowerLevel10k 三件套，然后安装 zsh-autosuggestions、zsh-syntax-highlighting 两个插件，即可获得比较好的体验。 Linux Shell 环境下一般使用 Vim 作为编辑器。Vim 使用不同模式，以及按键串行表达语义获取编辑效率上的提升。如果想让 Vim 功能丰富，需要装很多拓展以及配置文件。对于小白来说，命令式的 Shell 环境加上 Vim 的陌生，劝退效果是极佳的。如果想使用 Vim 作为开发环境，首先需要熟悉 Vim 常用操作，然后建议使用其他人配置好的 Vim 配置文件（像 vim-init、SpaceVim），慢慢在别人的基础上做一些修改，等熟悉了 Vim 的脚本语言以及配置项再做针对自己定制化的改进。 Linux 下还有 tmux 提升使用体验，带来 Windows 下 Window（窗口）一样的体验，同时执行一些前台任务也不会因为终端掉线而直接终止，保存云端的工作环境。 编辑器环境编辑器和 IDE 之间的关系，其实是互补的。对于开发特定种类的项目，如果没有特殊需求，IDE 往往是开箱即用，并提供一整套完善的项目开发辅助解决方案，无论是静态代码检查、代码重构乃至是团队协作、超大型项目分析构建，其背后有一整个团队来提供专业支持。像是 JetBrains 的 Rider 可以很好的处理 UE 的反射宏，针对 UE 的特性做特别的提示。而编辑器想要获得这些功能，一般需要装很多插件，需要自己做一些针对性的配置；有些功能可能是基于文本实现的，可能没有 IDE 基于语义实现的效果要好；还有些功能比较冷僻，可能相关插件无人维护甚至是根本没有；即使有插件提供这些功能，功能之间的集成度上可能也没有 IDE 那么高。 相较于 IDE 这种偏科生，编辑器更像是一位全科生，它的全能来自于高度可拓展。功能上的高度可拓展，给予开发上一致的体验；配置上的高自由度，给与用户将开发环境打造舒适的能力。开放的拓展生态、广泛的功能覆盖、用户配置高自由度，这些是单独团队维护主体功能的 IDE 所难以比拟的。由于瞄准的目标是通用编程，所以有些概念也会变得抽象一些，对用户理解配置的能力也会有要求。比如，作为小白，很难理解为什么 VScode 编写调试一个 C++ 文件需要配置 tasks.json 还有 launch.json 这么复杂，配置不对一个红红的 Error 弹出，体验直接不如 Dev c++。 VScodeVScode 是个人目前主要使用的编辑器，它有丰富的插件生态、Remote Development、高自由度的用户配置，并且开源免费 。在付出一点时间调教之后，可以用的很舒服。 想要让计算机按预期运行，必须得在合适的上下文中，无歧义的指明想要进行的操作。对于编辑器来说，容易存在歧义的问题，键盘上大部分按键都是被作为输入字符处理的，所以想要进行编辑以外的操作，就显得不那么方便。一般来说，有以下几种比较主流的解决方式： 组合键，也叫快捷键，通过 Ctrl Shift 等控制字符和普通字符一起按下表明在需要进行非键入操作。优点是方便易理解、系统级的支持，一般软件大量采用这种设计，然而全局快捷键冲突也十分常见，最典型的莫过于系统中文输入法 Ctrl + Space 切换中英文，而VScode拿此当手动触发智能提示补全的快捷键。 Vim 模式，类似硬件层面上的 Capslock，在不同的模式下，按键被赋予不同的含义。通常模式下，普通字符具有跳转翻页光标移动的功能，只有当进入到编辑模式，才能像一般编辑器那样进行字符输入。 Leader 键，避免快捷键冲突的最好方法，就是自己再造一个软件层面的键，它就是 Leader 键。类似大部分编程语言中字符串中转义符号\\，紧跟在 Leader 键之后的输入将被认为是另一种含义。Ctrl + K 一般作为 VScode 中的 Leader 键存在，连续输入 Ctrl+K、Ctrl+S，将打开 VScode 快捷键 UI 界面。 命令面板，对于常用的功能，向上面一样绑定一个快捷键很方便，但对于那些冷僻的功能，可能连绑定的快捷键都忘了。而命令面板可以通过输入描述或是关键字来筛选你需要的功能，类似一个 Google Search，同时能兼备很多终端命令行下的特点。在 VScode 下可以按 Ctrl+Shift+P 唤出命令面板，可以搜索需要的命令，前缀&gt;代表现在要查找命令，而删除前缀进入的是文件名称查找。 VScode 比较难受的是快捷键映射，因为需要兼容大部分 Win 默认的快捷键设置习惯，所以使用体验并不是很好。Alt 默认聚焦到桌面应用的菜单选项栏中，绑定一堆展示菜单栏选项，直接禁了然后绑定到一些类似：选择配置debug、选择tasks运行这样的比较方便。 VScode 支持使用 CSS 属性来调节字体特性，配合Iosevka这样特性丰富的开源字体，可以很好满足需要。斜体、粗体、语义着色，这些所见即所得的提示，有时候也能帮助理解代码。 最后推荐一些通用插件：BookMarks、Bracket Select、Error Lens、CodeSnap、Git File History、jumpy","link":"/2022/04/10/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%BE%E6%8C%87%E5%8D%97/"},{"title":"游戏编程gist","text":"从源头去做事件通知 谁改变谁去通知 (并未避免初始化的问题) 事件分发两种 异步和同步 同步可能出现连续触发导致诡异的调用层级，异步则可能需要更多的代码检查上下文 客户端以服务端时间线为准，那如果时间线客户端先于服务端执行，不可避免的会碰到回滚的问题。但等待服务端时间线执行之后客户端再执行，延迟就会比较高。 逻辑与表现分离，对表现来说可以多帧渲染不影响逻辑，对逻辑来说可以跨双端跑。 为什么要有我的概念，因为网络游戏两者并不能算是对等实体，其他玩家行为是服务器转发来的合法数据，本地玩家行为是体验优先本地立即响应却不具有一致性的。 数据热更要比代码热更来得更加方便，但依旧可能读取不一致的数据出错 字面量不具有逻辑，逻辑交由上下文管理，因此是上下文无关的，可以方便在不同逻辑之间做交换 字面量之间要做出区分，即需要传给逻辑后表现出多态行为，就得包含自解释数据 编辑器编辑策划配置数据要么通过表格的语义来决定，要么就像编程一样通过“元数据”增加表达语义能力，来组织关系 事件注册这种异步调用需要注意不同 Entity 上的使用，这种事件监听转换为单次的消息通知，然后自己分发事件监听可以避免异步逻辑 组合 ~ 波粒二象性 组合机制 继承 ~ 子类能在所有父类上下文中使用 Python 每一个函数都是一个多态，最好相同的名字有一致的语义，结构性子类型系统依赖于类型中隐式的模式，困难的是维护重要的隐式模式 Python 多重继承 可以用来解决冲突的问题，但更适合层次需要经常调整的逻辑，一次函数调用就像是走过一个协议栈 注意代码（或系统上的）中的相互指涉以及自我指涉，逻辑上的不完备会导致死循环或者悖论导致错误 首先考虑目标是什么，这个目标会有什么性质，这些性质会约束原语语义，以及定下整个框架模型 团队人员需要统一概念，需要有相似的惯用法，这样代码沟通成本会降低 代码风格最后跟语言风格尽量一致，能最大的利用生态，而且就像顺着纹理下刀一样，会更省力","link":"/2022/08/30/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8Bgist/"},{"title":"理解右值语义","text":"个人对右值语义的理解 理解右值语义右值语义是C++11引入的一项特性，本文从个人理解的角度来解释右值语义的作用，希望能对您有帮助。 要理解右值语义，首先需要知道对象与资源。一个对象可能持有一个资源，或者不持有资源。 123456789101112131415161718192021222324class Object {public: // 不持有资源 Object() { resource = nullptr; } // 持有一个int*资源 Object(int *ptr) { resource = ptr; } // 传值 Object(const Object &amp;obj) { resource = new int(); *resource = *obj.resource; } // 析构时需要对不持有资源进行单独处理 ~Object() { if (resource) { delete resource; } }private: int *resource;}; 当你传值去构造一个对象时，按照值语义，构造出来的对象与原对象之间是相互独立的，即对构造出来的对象进行任意修改都不应影响到原对象。（想想看，在传值一个int的时候，对形参的改变会影响到实参吗？）所以，当你写复制构造函数和重载复制赋值运算符时，应该进行一次深拷贝，对应到动态内存管理中，就是自己需要再分配一块动态内存，并将原动态内存上的值相对应的复制过来。 所以我们为什么需要区分左值右值呢？因为一个左值往往代表着后面还需要使用它（它可以被后续使用到，它仍能被标识），而右值意味着使用机会只有这一次（它没有被标识，后续根本无法引用它）。在这个地方，我们就可以对右值进行一次性能优化，既然对象将要消亡，我们应该把对象持有的资源“移动”到需要它的地方。落实到动态内存管理中，我们可以进行一次浅拷贝，并直接将原对象指针置为空，这样就节省了一次内存分配与释放的开销。 12Object a = Object(new int(1));// 右边是一个临时对象，按理来说我们可以进行一次“移动”操作，然而按照值语义，我们只能对其进行一次深拷贝 解决方案是对值语义进行一次扩充，我们需要区分左值与右值，在传递左值与右值时进行两组不同的操作。通过加入右值引用，我们可以重载出移动构造函数和移动赋值运算符。对于左值，我们可以使用复制类型的函数保证独立性，对于右值，我们可以使用移动类型的函数提升其效率。在传递容器时，这显得相关重要，因为每一次深拷贝的开销都将是巨大的。 延申阅读eg1. C++11中将值类型具体分为了左值，将亡值，纯右值。 eg2. 对于左值最后一次使用，可以使用std::move提高效率，它将一个左值转换为右值。 eg3. 通过左值引用，右值引用类型可以区分左值右值，结合C++模板推导规则，搞出了万能引用，通过将左值右值信息编码在类型信息中，实现了完美转发。 eg4. 常见的场景中，一般在函数出参入参会牵涉到右值语义的问题，详细见Effective Modern C++ 条款25 eg5. 为什么c++的queue的pop没有返回值？","link":"/2020/11/06/%E7%90%86%E8%A7%A3%E5%8F%B3%E5%80%BC%E8%AF%AD%E4%B9%89/"},{"title":"调度gist","text":"对于实时性要求高的服务器： 提前做 准备好做 整理做 独立做（减少重复） 慢慢做 攒批做 并行做 事务做 选择策略做 不做了（择机再做）延迟做","link":"/2022/05/18/%E8%B0%83%E5%BA%A6gist/"}],"tags":[{"name":"Idea","slug":"Idea","link":"/tags/Idea/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"Tool","slug":"Tool","link":"/tags/Tool/"},{"name":"Coding","slug":"Coding","link":"/tags/Coding/"}],"categories":[{"name":"Coding","slug":"Coding","link":"/categories/Coding/"},{"name":"PL","slug":"PL","link":"/categories/PL/"},{"name":"Gist","slug":"Gist","link":"/categories/Gist/"}]}